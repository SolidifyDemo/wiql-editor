export abstract class Symbol { }
/** symbols generated by the lexer */
export abstract class Token extends Symbol {
    //include line and column numbers for better debugging.
    constructor(readonly line: number, readonly column: number) {
        super();
    }
}
//Keywords
export class Select extends Token { }
export class From extends Token { }
export class Where extends Token { }
export class Order extends Token { }
export class By extends Token { }
export class Asc extends Token { }
export class Desc extends Token { }
export class Asof extends Token { }
export class Not extends Token { }
export class Ever extends Token { }
export class In extends Token { }
export class Like extends Token { }
export class Under extends Token { }
export class WorkItems extends Token { }
export class WorkItemLinks extends Token { }
export class And extends Token { }
export class Or extends Token { }
export class Contains extends Token { }
export class Words extends Token { }
//Operators
export class RParen extends Token { }
export class LParen extends Token { }
export class RSqBracket extends Token { }
export class LSqBracket extends Token { }
export class Comma extends Token { }
export class Equals extends Token { }
export class NotEquals extends Token { }
export class GreaterThan extends Token { }
export class LessThan extends Token { }
export class GreaterOrEq extends Token { }
export class LessOrEq extends Token { }

export class UnexpectedToken extends Token {
    public readonly value: string;
    constructor(line: number, column: number, value: string) {
        super(line, column);
        this.value = value;
    }
}
export class String extends Token {
    public readonly value: string;
    constructor(line: number, column: number, value: string) {
        super(line, column);
        this.value = value;
    }
}
export class NonterminatingString extends Token {
    public readonly value: string;
    constructor(line: number, column: number, value: string) {
        super(line, column);
        this.value = value;
    }
}
export class Field extends Token {
    constructor(line: number, column: number, readonly identifier: string) {
        super(line, column);
        this.identifier = identifier;
    }
}
export class Number extends Token {
    constructor(line: number, column: number, readonly numberString: string) {
        super(line, column);
    }
}
export class EOF extends Token { }

export class ContainsWords extends Symbol { }
export class DateTime extends Symbol {
    constructor(readonly dateString: String) {
        super();
    }
}
export class OrderByFieldList extends Symbol {
    constructor(readonly field: Field,
        readonly ascDesc?: Asc | Desc,
        readonly restOfList?: OrderByFieldList) {
        super();
    }
}
export class FieldList extends Symbol {
    constructor(readonly field: Field, readonly restOfList?: FieldList) {
        super();
    }
}
export class ConditionalOperator extends Symbol {

    constructor(conditionToken: 
    Equals | NotEquals | GreaterThan | GreaterOrEq | LessThan | LessOrEq | Contains | ContainsWords);
    constructor (conditoinToken: Like | Under, isEver: boolean, isNot: boolean);
    constructor(readonly conditionToken: Equals | NotEquals | GreaterThan | GreaterOrEq | LessThan | LessOrEq | Contains | Like | Under,
        readonly isEver = false, readonly isNot = false) {
        super();
    }
}
export class Value extends Symbol {
    constructor(readonly value: Number | String | DateTime) {
        super();
    }
}
export class ValueList extends Symbol {
    constructor(readonly value: Value, readonly restOfList: ValueList) {
        super();
    }
}
/** Combines the expression[1 - 4] from ebnf into one */
export class LogicalExpression extends Symbol {
    constructor(readonly condition: ConditionalExpression,
        readonly everNot?: Ever | Not,
        readonly orAnd?: Or | And,
        readonly expression?: LogicalExpression) {
        super();
    }
}
export class ConditionalExpression extends Symbol {
    public readonly expression?: LogicalExpression

    public readonly field?: Field;

    public readonly conditionalOperator?: ConditionalOperator;
    public readonly value?: Value;

    public readonly isNot: boolean;
    public readonly valueList?: ValueList;
    constructor(expression: LogicalExpression);
    constructor(field: Field, cond: ConditionalOperator, value: Value);
    constructor(field: Field, isin: boolean, value: ValueList);
    constructor(arg1: Field | LogicalExpression, arg2?: ConditionalOperator | boolean, arg3?: Value | ValueList) {
        super();
        if (arg1 instanceof LogicalExpression) {
            this.expression = arg1;
        } else if (arg2 instanceof ConditionalOperator && arg3 instanceof Value) {
            this.field = arg1;
            this.conditionalOperator = arg2;
            this.value = arg3;
            let a: number;
        } else if (typeof arg2 === 'boolean' && arg3 instanceof ValueList) {
            this.field = arg1;
            this.isNot = arg2;
            this.valueList = arg3;
        } else {
            throw new Error('Improper ConditionalExpression arguments');
        }
    }
}
export class FlatSelect extends Symbol {
    constructor(readonly fieldList: FieldList,
        readonly whereExp?: LogicalExpression,
        readonly orderBy?: OrderByFieldList,
        readonly asOf?: DateTime) {
        super();
    }
}
//Link symbols not copied as workItemLink queries are not supported yet

export function getSymbolName(symbolClass: Function) {
    const str: string = symbolClass.toString();
    const match = str.match(/function (\S+)(?=\()/);
    if (match) {
        return match[1].toUpperCase();
    }
    throw new Error('type is not a function');
}
